-- Code your design here
-- Código VHDL:
library ieee;
use ieee.std_logic_1164.all;

entity HammingWeight is
   generic(N: integer := 4);	--entrada com 4-bit (16 valores: 0~15)
   port(x: in std_logic_vector(N-1 downto 0);
        y: out integer range 0 to N);
end entity;

architecture arq_HammingWeight of HammingWeight is
begin
   process(x)
      variable conta_1, flag_1: integer;
   begin
      conta_1 := 0; flag_1 := 0;
      for i in 0 to N-1 loop
         if x(i) = '1' then flag_1 := 1;
            else flag_1 := 0;
         end if;
         conta_1 := conta_1 + flag_1;
      end loop;
      y <= conta_1;    
   end process;
end architecture;



-- Code your testbench here
-- Testbench para simulação:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;		--para usar "to_unsigned"

entity tb_HammingWeight is
	generic(M: integer :=4);	--entrada com 4-bit
end entity;

architecture arq_tb_HammingWeight of tb_HammingWeight is
   signal tx: std_logic_vector(M-1 downto 0);
   signal ty: integer range 0 to M;
begin
	uut: entity work.HammingWeight(arq_HammingWeight)
	generic map(M)
    port map(tx, ty);
	process
      variable i: integer;
	begin
      for i in 0 to 2**M-1 loop
         tx <= std_logic_vector(to_unsigned(i, M));
         wait for 10 ns;
      end loop;
	end process;
end architecture;