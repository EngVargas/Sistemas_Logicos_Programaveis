
-- Code your design here
-- Código VHDL:
library ieee;
use ieee.std_logic_1164.all;

entity LZ is
   generic(N: integer := 4);	--entrada com 4-bit (16 valores: 0~15)
   port(x: in std_logic_vector(N-1 downto 0);
        y: out integer range 0 to N);
end entity;

architecture arq_LZ of LZ is
begin
   process(x)
      variable temp: integer range 0 to N; --variável temporária
   begin
      temp := 0;
      --for i in x'range loop		--Ok
      --for i in 0 to N-1 loop		--erro
      for i in N-1 downto 0 loop	--VHDL varre da maior para menor
         exit when x(i) = '1';	--testa se temos um 1 na posição i
         temp := temp + 1;
      end loop;
      y <= temp;  				--guarda o valor da variável no signal
   end process;
end architecture;



-- Code your testbench here
-- Testbench para simulação:
library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;		--para usar "to_unsigned"

entity tb_LZ is
	generic(M: integer :=4);	--entrada com 4-bit
end entity;

architecture arq_tb_LZ of tb_LZ is
   signal tx: std_logic_vector(M-1 downto 0);
   signal ty: integer range 0 to M;
begin

   uut: entity work.LZ(arq_LZ)
        generic map(M) port map(x=>tx, y=>ty);
        
   process
     variable i: integer range 0 to 2**M-1;
     begin
        for i in 0 to 2**M-1 loop
          tx <= std_logic_vector(to_unsigned(i, M));
          wait for 10 ns;
        end loop;
     end process;  
end architecture;